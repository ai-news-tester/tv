<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IPTV Live Channels</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background: #f2f2f2;
        margin: 0;
        padding: 20px;
      }
      h1 {
        text-align: center;
      }
      #last-updated {
        text-align: center;
        font-size: 0.9rem;
        color: #333;
        margin-bottom: 20px;
      }
      #channels {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        justify-content: center;
      }
      .channel {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 10px;
        width: 200px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        text-align: center;
      }
      .channel img {
        max-width: 100%;
        margin-bottom: 10px;
      }
      .channel h3 {
        font-size: 1.1rem;
        margin: 0.5em 0;
      }
      .channel p {
        font-size: 0.9rem;
        color: #666;
      }
      .channel a {
        display: inline-block;
        margin-top: 10px;
        padding: 5px 10px;
        background: #2196f3;
        color: #fff;
        text-decoration: none;
        border-radius: 4px;
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <h1>IPTV Live Channels</h1>
    <div id="last-updated">
      Last Updated: <span id="update-time">Never</span>
    </div>
    <div id="channels">
      <p>Loading channels...</p>
    </div>

    <script>
      // Will hold channel data once the playlist is fetched
      let channelsList = [];
  
      document.addEventListener("DOMContentLoaded", function () {
        // Your provided playlist URL
        const playlistUrl =
          "http://tv.nova-iptv.com:80/get.php?username=Antonia_Baumgartner&password=kYa7tNPpje&type=m3u_plus";
        // Using AllOrigins proxy to bypass CORS issues:
        const proxyUrl =
          "https://api.allorigins.hexocode.repl.co/get?disableCache=true&url=" +
          encodeURIComponent(playlistUrl);
  
        fetch(proxyUrl)
          .then((response) => response.json())
          .then((data) => {
            const playlist = data.contents;
            channelsList = parsePlaylist(playlist);
            if (channelsList.length === 0) {
              document.getElementById("channels").innerHTML =
                "<p>No channels found in the playlist.</p>";
              return;
            }
            // Do an immediate live status update.
            updateLiveChannels();
            // Then re-run live status check every 10 minutes (600,000ms)
            setInterval(updateLiveChannels, 600000);
          })
          .catch((error) => {
            console.error("Error fetching playlist:", error);
            document.getElementById("channels").innerHTML =
              "<p>Error loading playlist.</p>";
          });
      });
  
      // Parses the M3U playlist text and returns an array of channel objects.
      function parsePlaylist(text) {
        const lines = text.split("\n");
        let channels = [];
        let currentChannel = null;
  
        lines.forEach((line) => {
          line = line.trim();
          if (line.startsWith("#EXTINF:")) {
            // Example format:
            // #EXTINF:-1 tvg-id="123" tvg-name="Channel One" tvg-logo="http://logo.png",
            // Channel One
            const regex = /(\w+?)="(.*?)"/g;
            let attr = {};
            let match;
  
            while ((match = regex.exec(line)) !== null) {
              attr[match[1]] = match[2];
            }
  
            // Get display name (text after comma)
            const commaIndex = line.indexOf(",");
            if (commaIndex !== -1) {
              attr.name = line.substring(commaIndex + 1).trim();
            }
  
            currentChannel = attr;
          } else if (line && !line.startsWith("#")) {
            // The non-comment line after #EXTINF is assumed to be the stream URL.
            if (currentChannel) {
              currentChannel.url = line;
              channels.push(currentChannel);
              currentChannel = null;
            }
          }
        });
  
        return channels;
      }
  
      // Updates the live channels list by checking each channel.
      function updateLiveChannels() {
        const container = document.getElementById("channels");
        container.innerHTML = "<p>Checking live channels...</p>";
  
        // Create an array of promises for each channel's live check.
        const checks = channelsList.map((channel) =>
          checkChannel(channel).then((isLive) => ({ channel, isLive }))
        );
  
        Promise.all(checks).then((results) => {
          container.innerHTML = "";
  
          // Update the timestamp.
          document.getElementById("update-time").textContent =
            new Date().toLocaleString();
  
          const liveChannels = results.filter((result) => result.isLive);
  
          if (liveChannels.length === 0) {
            container.innerHTML =
              "<p>No live channels available at the moment.</p>";
            return;
          }
  
          liveChannels.forEach((result) => {
            const item = document.createElement("div");
            item.className = "channel";
  
            let html = "";
            if (result.channel["tvg-logo"]) {
              html += `<img src="${result.channel["tvg-logo"]}" alt="${
                result.channel.name
              }" />`;
            }
            html += `<h3>${result.channel.name}</h3>`;
            if (result.channel["tvg-name"]) {
              html += `<p>${result.channel["tvg-name"]}</p>`;
            }
            html += `<a href="${result.channel.url}" target="_blank">
                Watch Stream</a>`;
            item.innerHTML = html;
            container.appendChild(item);
          });
        });
      }
  
      // Checks if a channel's stream is live by attempting to load video metadata.
      // Resolves with true if metadata loads within 5 seconds, otherwise false.
      function checkChannel(channel) {
        return new Promise((resolve) => {
          const video = document.createElement("video");
          video.preload = "metadata";
          video.src = channel.url;
  
          let resolved = false;
          // 5 seconds timeout for each channel check.
          const timeout = setTimeout(() => {
            if (!resolved) {
              resolved = true;
              video.src = "";
              resolve(false);
            }
          }, 5000);
  
          video.addEventListener("loadedmetadata", () => {
            if (!resolved) {
              resolved = true;
              clearTimeout(timeout);
              video.src = "";
              resolve(true);
            }
          });
  
          video.addEventListener("error", () => {
            if (!resolved) {
              resolved = true;
              clearTimeout(timeout);
              video.src = "";
              resolve(false);
            }
          });
  
          // Start loading the stream
          video.load();
        });
      }
    </script>
  </body>
</html>
