<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,
      initial-scale=1.0" />
    <title>IPTV Live Channels (Debug Mode)</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background: #f2f2f2;
        margin: 0;
        padding: 20px;
      }
      h1 {
        text-align: center;
      }
      #status {
        text-align: center;
        font-size: 0.9rem;
        color: #333;
        margin-bottom: 20px;
      }
      #channels {
        max-width: 800px;
        margin: auto;
      }
      .channel {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 10px;
        margin: 5px 0;
      }
      .offline {
        opacity: 0.5;
      }
      .live {
        border-left: 5px solid #4caf50;
      }
      .indicator {
        font-size: 0.85rem;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <h1>IPTV Channels (Debug Mode)</h1>
    <p id="status">Loading playlist...</p>
    <div id="channels"></div>
    <script>
      const DEBUG = true;
      function log(...args) {
        if (DEBUG) console.log(...args);
      }

      /**
       * Fetch the playlist using the AllOrigins proxy.
       */
      function fetchPlaylist() {
        const playlistUrl =
          "http://tkosportz.live:25461/get.php?username=jmdpirate&password=864569&type=m3u_plus";
        const proxyUrl =
          "https://api.allorigins.hexocode.repl.co/get?disableCache=true&url=" +
          encodeURIComponent(playlistUrl);
        log("Fetching playlist from:", proxyUrl);
        return fetch(proxyUrl)
          .then((res) => {
            if (!res.ok) {
              throw new Error("Network response was not ok.");
            }
            return res.json();
          })
          .then((data) => data.contents);
      }

      /**
       * Parse the M3U playlist text into an array of channel objects.
       *
       * Each #EXTINF line is parsed for attributes (like tvg-logo, tvg-name)
       * and the text after the comma is used as the channel display name.
       * The subsequent non-comment line is assumed to be the stream URL.
       */
      function parsePlaylist(text) {
        const lines = text.split("\n");
        const channels = [];
        let currentChannel = null;
        for (let line of lines) {
          line = line.trim();
          if (line.startsWith("#EXTINF:")) {
            // Use regex to extract key="value" pairs.
            const regex = /(\w+?)="(.*?)"/g;
            const attr = {};
            let match;
            while ((match = regex.exec(line)) !== null) {
              attr[match[1]] = match[2];
            }
            // The text after the comma is used as the channel name.
            const commaIndex = line.indexOf(",");
            if (commaIndex !== -1) {
              attr.name = line.substring(commaIndex + 1).trim();
            }
            currentChannel = attr;
          } else if (line && !line.startsWith("#")) {
            if (currentChannel) {
              currentChannel.url = line;
              channels.push(currentChannel);
              currentChannel = null;
            }
          }
        }
        return channels;
      }

      /**
       * Check if a channel is live by trying to load its video metadata.
       * This creates a hidden video element with crossOrigin set to "anonymous".
       * The promise resolves to true if metadata loads within 5 seconds, else false.
       */
      function checkChannel(channel) {
        return new Promise((resolve) => {
          const video = document.createElement("video");
          video.crossOrigin = "anonymous";
          video.preload = "metadata";
          video.src = channel.url;
  
          let resolved = false;
          const timer = setTimeout(() => {
            if (!resolved) {
              resolved = true;
              video.remove();
              resolve(false);
            }
          }, 5000);
  
          video.addEventListener("loadedmetadata", () => {
            if (!resolved) {
              resolved = true;
              clearTimeout(timer);
              video.remove();
              resolve(true);
            }
          });
          video.addEventListener("error", () => {
            if (!resolved) {
              resolved = true;
              clearTimeout(timer);
              video.remove();
              resolve(false);
            }
          });
          // Start loading the stream.
          video.load();
        });
      }

      /**
       * Display channels along with a live/offline indicator.
       */
      function displayChannels(channels) {
        const container = document.getElementById("channels");
        container.innerHTML = "";
        if (channels.length === 0) {
          container.innerHTML =
            "<p>No channels to display. Perhaps none are live.</p>";
          return;
        }
  
        channels.forEach((ch) => {
          const div = document.createElement("div");
          div.className = "channel";
          let html = `<div class="indicator">${
            ch.isLive ? "LIVE" : "OFFLINE"
          }</div>`;
          if (ch["tvg-logo"]) {
            html += `<img src="${ch["tvg-logo"]}" alt="${ch.name ||
              "Channel"} logo" style="max-width:100px"/>`;
          }
          html += `<h3>${ch.name || "Unnamed Channel"}</h3>`;
          if (ch["tvg-name"]) {
            html += `<p>${ch["tvg-name"]}</p>`;
          }
          html += `<p><a href="${ch.url}" target="_blank">Watch Stream</a></p>`;
          div.innerHTML = html;
          if (ch.isLive) {
            div.classList.add("live");
          } else {
            div.classList.add("offline");
          }
          container.appendChild(div);
        });
      }

      /**
       * Update channels by fetching the playlist, parsing it,
       * checking every channel's live status, and then displaying them.
       */
      function updateChannels() {
        document.getElementById("status").textContent =
          "Updating channels...";
  
        fetchPlaylist()
          .then((playlistText) => {
            log("Playlist fetched successfully.");
            const channels = parsePlaylist(playlistText);
            log("Parsed channels:", channels);
            if (!channels.length) {
              document.getElementById("status").textContent =
                "No channels found in the playlist.";
              return;
            }
  
            // Check all channels for live status.
            Promise.all(
              channels.map((ch) =>
                checkChannel(ch).then((isLive) => {
                  ch.isLive = isLive;
                  return ch;
                })
              )
            ).then((results) => {
              log("Live check results:", results);
              displayChannels(results);
              document.getElementById("status").textContent =
                "Last Updated: " + new Date().toLocaleString();
            });
          })
          .catch((error) => {
            console.error("Error fetching playlist:", error);
            document.getElementById("status").textContent =
              "Error loading playlist.";
          });
      }
  
      // Update channels on initial load and every 10 minutes.
      document.addEventListener("DOMContentLoaded", () => {
        updateChannels();
        setInterval(updateChannels, 600000); // 600,000 ms = 10 minutes
      });
    </script>
  </body>
</html>
